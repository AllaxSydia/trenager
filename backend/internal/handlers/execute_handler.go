package handlers

import (
	"backend/internal/executor"
	"backend/internal/models"
	"backend/internal/services"
	"encoding/json"
	"log"
	"net/http"
)

// –ö–æ—Ä–æ—á–µ, —Ç—É—Ç –≤—ã–±–∏—Ä–∞–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –ª–∏–±–æ Docker –ª–∏–±–æ –õ–æ–∫–∞–ª—å–Ω–æ
// –ø–æ—Ç–æ–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ –µ–¥–∏–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞

var dockerService *services.DockerService // –ò–∑–æ–ª—è—Ü–∏—è
var localExecutor *executor.LocalExecutor // –ë—ã—Å—Ç—Ä–æ

func init() {
	var err error
	dockerService, err = services.NewDockerService()
	if err != nil {
		log.Printf("Warning: Docker service not available: %v", err)
		log.Println("Running in local execution mode")
	} else {
		log.Println("‚úÖ Docker service initialized successfully")
	}

	// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å
	localExecutor = executor.NewLocalExecutor()
	// –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è —Å–æ–∑–¥–∞—Ç—å Docker —Å–µ—Ä–≤–∏—Å –¥–ª—è –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, —Ç–æ
	// –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π —Ä–µ–∂–∏–º
	// –õ–æ–∫–∞–ª–∫–∞ —Å–æ–∑–¥–∞—ë—Ç—Å—è –≤—Å–µ–≥–¥–∞
}

func ExecuteHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, `{"success": false, "message": "Only POST method allowed"}`, http.StatusMethodNotAllowed)
		return
	}
	// –ü–∞—Ä—Å–∏–Ω–≥ JSON
	var req models.ExecutionRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, `{"success": false, "message": "Invalid JSON"}`, http.StatusBadRequest)
		return
	}

	log.Printf("üîß Executing code for language: %s", req.Language)

	var response models.ExecutionResponse

	// –ü—Ä–æ–±—É–µ–º Docker —Å–Ω–∞—á–∞–ª–∞
	if dockerService != nil {
		log.Println("üê≥ Attempting Docker execution...")
		result, err := dockerService.ExecuteCode(req.Code, req.Language)
		if err != nil {
			log.Printf("‚ùå Docker execution failed: %v", err)
			log.Println("üîÑ Falling back to local execution...")
			response = executeCodeWithLocalExecutor(req.Code, req.Language)
		} else {
			log.Printf("‚úÖ Docker execution successful, output: %s", result.Output)
			response = models.ExecutionResponse{
				Success: result.Success,
				Message: "Code executed successfully via Docker",
				Output:  result.Output,
			}
			if !result.Success {
				response.Message = "Code execution failed in Docker"
			}
		}
	} else {
		log.Println("üîÑ Docker not available, using local execution...")
		response = executeCodeWithLocalExecutor(req.Code, req.Language)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∏—Å–ø–æ–ª—å–∑—É—é—â–∞—è LocalExecutor –¥–ª—è –≤—Å–µ—Ö —è–∑—ã–∫–æ–≤
func executeCodeWithLocalExecutor(code, language string) models.ExecutionResponse {
	log.Printf("üîß Executing %s code with local executor", language)

	result, err := localExecutor.Execute(code, language)

	if err != nil {
		log.Printf("‚ùå Local execution error: %v", err)
		return models.ExecutionResponse{
			Success: false,
			Message: "Execution failed: " + err.Error(),
			Output:  "",
		}
	}

	// –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–∑ LocalExecutor –≤ models.ExecutionResponse
	exitCode := result["exitCode"].(int)
	output := result["output"].(string)
	errorMsg := result["error"].(string)

	success := exitCode == 0
	finalOutput := output
	if errorMsg != "" {
		finalOutput = errorMsg
		if output != "" {
			finalOutput = output + "\n" + errorMsg
		}
	}

	message := "–ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ (–ª–æ–∫–∞–ª—å–Ω–æ)"
	if !success {
		message = "–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–¥–∞"
	}

	log.Printf("‚úÖ Local execution completed, success: %t, output length: %d", success, len(finalOutput))

	return models.ExecutionResponse{
		Success: success,
		Message: message,
		Output:  finalOutput,
	}
}
