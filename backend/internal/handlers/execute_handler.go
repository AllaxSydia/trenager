package handlers

import (
	"backend/internal/models"
	"backend/internal/services"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"time"
)

var dockerService *services.DockerService

func init() {
	var err error
	dockerService, err = services.NewDockerService()
	if err != nil {
		log.Printf("Warning: Docker service not available: %v", err)
		log.Println("Running in local execution mode")
	} else {
		log.Println("‚úÖ Docker service initialized successfully")
	}
}

func ExecuteHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, `{"success": false, "message": "Only POST method allowed"}`, http.StatusMethodNotAllowed)
		return
	}

	var req models.ExecutionRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, `{"success": false, "message": "Invalid JSON"}`, http.StatusBadRequest)
		return
	}

	log.Printf("üîß Executing code for language: %s", req.Language)

	var response models.ExecutionResponse

	// –ü—Ä–æ–±—É–µ–º Docker —Å–Ω–∞—á–∞–ª–∞
	if dockerService != nil {
		log.Println("üê≥ Attempting Docker execution...")
		result, err := dockerService.ExecuteCode(req.Code, req.Language)
		if err != nil {
			log.Printf("‚ùå Docker execution failed: %v", err)
			log.Println("üîÑ Falling back to local execution...")
			response = executeCodeLocally(req.Code, req.Language)
		} else {
			log.Printf("‚úÖ Docker execution successful, output: %s", result.Output)
			response = models.ExecutionResponse{
				Success: result.Success,
				Message: "Code executed successfully via Docker",
				Output:  result.Output,
			}
			if !result.Success {
				response.Message = "Code execution failed in Docker"
			}
		}
	} else {
		log.Println("üîÑ Docker not available, using local execution...")
		response = executeCodeLocally(req.Code, req.Language)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func executeCodeLocally(code, language string) models.ExecutionResponse {
	// –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ Go –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
	if language != "go" {
		return models.ExecutionResponse{
			Success: false,
			Message: "–õ–æ–∫–∞–ª—å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ Go",
			Output:  "–î–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–¥–∞ –Ω–∞ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö —Ç—Ä–µ–±—É–µ—Ç—Å—è Docker",
		}
	}

	log.Printf("üîß Executing Go code locally: %s", code)

	// –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
	tmpDir, err := os.MkdirTemp("", "go_exec_*")
	if err != nil {
		return models.ExecutionResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to create temp dir: %v", err),
			Output:  "",
		}
	}
	defer os.RemoveAll(tmpDir)

	// –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª —Å –∫–æ–¥–æ–º
	filePath := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return models.ExecutionResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to write code file: %v", err),
			Output:  "",
		}
	}

	log.Printf("üìÅ Code written to: %s", filePath)

	// –í—ã–ø–æ–ª–Ω—è–µ–º —Å —Ç–∞–π–º–∞—É—Ç–æ–º
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, "go", "run", filePath)
	output, err := cmd.CombinedOutput()

	// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
	if ctx.Err() == context.DeadlineExceeded {
		return models.ExecutionResponse{
			Success: false,
			Message: "Execution timeout (30 seconds exceeded)",
			Output:  "–ö–æ–¥ –≤—ã–ø–æ–ª–Ω—è–ª—Å—è —Å–ª–∏—à–∫–æ–º –¥–æ–ª–≥–æ",
		}
	}

	if err != nil {
		return models.ExecutionResponse{
			Success: false,
			Message: fmt.Sprintf("Execution error: %v", err),
			Output:  string(output),
		}
	}

	log.Printf("‚úÖ Local execution successful, output: %s", string(output))

	return models.ExecutionResponse{
		Success: true,
		Message: "–ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ (–ª–æ–∫–∞–ª—å–Ω–æ)",
		Output:  string(output),
	}
}
